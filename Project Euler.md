
# Project Euler (1-12)

This is an attempt at solving the problems in [Project Euler](https://projecteuler.net/). They're described as "a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve.". Being a mathematician myself, I thought it would be interesting to use these problems as fun brain teasers while also improving my Python. I can't guarantee that I will be right, but I will talk through my logic and give multiple solutions where I can to corroborate them. 

You'll also find I use "I" and "we" a lot and interchangeably. I do that out of habit and collaborative problem solving in classrooms. Hopefully it doesn't make this too annoying to read.

### [Problem 1 - Multiples of 3 and 5](https://projecteuler.net/problem=1)

**If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.**

A Natural number is a "counting number" i.e. a positive whole number. Looking at this, there are a few ways to do it. I will look at two way a brute force approach and a sequence approach.

*Method 1: Brute force*

We use a for loop and add up every number less than 1000 that is a multiple of 3 or 5.


```python
# If a number is a multiple of 3 or 5, then it is perfectly divisible by 3 or 5
# Thus, we take every number i less than 1000 and add it to our total if it is perfectly divible by 3 or 5. 

count=0
for i in range(1000):
    if i%3==0 or i%5==0:
        count+=i
        
count
```




    233168



*Method 2: Sequence Approach* 

Another way to think about this problem is that we are adding every 3rd and 5th number until we hit the limit value. Thus we can create 2 sequences (a 3-step and 5-step sequence), amalgamate them and sum them. This avoids the use of a for loop and may (perhaps) perform better for a very large number. We create a function that does this instantaneously. Is this required? Definitely not, but why should that stop anything? 


```python
def fivethree(n):
    # List outputs out all the elements in range as a list
    # Set provides a unique list of elements
    # Thus we create a list in multiples of 3 and 5 and use set to get a unique list
    return(sum(set(list(range(0,n,3))+list(range(0,n,5)))))

print(fivethree(1000))
```

    233168


We can see from above that both come to the answer **233168**. On to the next one!

### [Problem 2 - Even Fibonacci numbers](https://projecteuler.net/problem=2)

**Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:**
**1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...**
**By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.**

We can start by creating a function that creates a Fibonacci sequence, below a certain value. This will form the basis upon which we'll proceed.


```python
def Fibo_Less(n):
    ans=[1,1]
    while ans[-1]+ans[-2]<n:
        ans.append(ans[-1]+ans[-2])
    return(ans)

# We do a quick test to see that it works.
Fibo_Less(100)
```




    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]



It looks like we have a candidate. Now we can apply a number of techniques to the Fibonacci sequence we've generated above. We'll try a couple here: Brute Force and  patterns.

*Method 1: Brute Force*

Here we take each element in the Fibonacci sequence less than 4 million, check that they are divisible by 2 and add them together.


```python
count=0
for i in Fibo_Less(4000000):
    if i%2==0:
        count+=i
count

```




    4613732



*Method 2: Number Patterns*

Let's take a look at the Fibonacci sequence below for numbers less than 8000.


```python
print(Fibo_Less(8000))
```

    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]


Notice anything? There's clear pattern for which numbers are even or odd. Every third number is even which the other two are odd. Recall that the sum of an even number and an odd number is odd while the sum of two even numbers or two odd numbers is even. Thus we end up a pattern of `odd`, `odd`,`odd+odd=even`,`even+odd=odd`,`odd+even=odd`,`odd+odd=even`,... For those seeking a more mathematically rigid solution, You can find a discussion on an [induction proof](https://math.stackexchange.com/questions/2386804/proof-that-every-third-fibonacci-number-is-even)

Now we can simply sum every third element of our Fibonacci sequence and we will have a sum of the evens. The answer should be the same as our brute force solution.


```python
sum(Fibo_Less(4000000)[2::3]) # This starts from 2 (the third element) and adds every third element
```




    4613732



Hence our solution is **4613732**. Great! Both methods match up. Let's move on the third problem.

### [Problem 3 -Largest prime factor](https://projecteuler.net/problem=3)

**The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?**

I'll try a brute force approach and then a slight modification to the brute force approach which should both result in the same answer.


*Method 1: Brute Force*

We create two functions here, one to check if a number is prime and another to find a numbers largest prime divisors.


```python
# The largest possible prime divisor of a number other than the number itself is its square root 

def is_prime(n):
    ans=True
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return(False)
    return(ans)

# We run these through to test
print(is_prime(29))
print(is_prime(13))
print(is_prime(13195))

# Looks like it works

def prime_div(n):
    ans=1
    for i in range(2,int(n**0.5)+1):
        if n%i==0 and is_prime(i):
            ans=i
    if ans==1:
        ans=n
    return(ans)

print(prime_div(13195))
# We should get 29, which we did. Looks like it works.

print(prime_div(600851475143))
# We get 6857! 

# Will do a quick check to confirm that 6857 is prime
is_prime(6857) # We get that it is in fact prime. Thus our answer is 6857
```

    True
    True
    False
    29
    6857





    True



*Method 2: Modified Approach*

We can do the same as before but employ a step up approach for the `prime_div` step instead. That is, we start from 2 (the smallest prime) and keep dividing by 2 until the number is no longer divisible by 2. We then move the quotient  to the next highest prime continuously until we end at 1. The largest number that is able to divide our number is thus the answer.


```python
def large_prime(n):
    ans=n
    
    for i in range(2,int(n**0.5)+1):
        while n%i==0:
            n=n/i
            ans=i
        if n==1:
            break
    return(ans)

large_prime(600851475143)
# Looks like that works as well. On to the next one.
```




    6857



### [Problem 4 - Largest palindrome product](https://projecteuler.net/problem=4)

**A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.Find the largest palindrome made from the product of two 3-digit numbers.**

Let's create a function to check if a number is palindromic. There's perhaps a numerical test we can apply, but I'm going to do it in a way that seems obvious to me. Convert the number to text, reverse it and check that both are equal.


```python
def is_pal(n):
    return(str(n)==str(n)[::-1])

# We run through to test it's right
print(is_pal(55155))
print(is_pal(551))
print(is_pal(202))
```

    True
    False
    True



```python
# We run a double loop from 999 to 100 and pick the largest number we find that is palindromic

ans=0
for i in range(100,1000):
    for j in range(100,1000):
        if is_pal(i*j) and i*j>ans:
            ans=i*j
            I=i
            J=j

print([I,j,ans])

# Largest Number is 906609
    
```

    [913, 999, 906609]


Hence our solution is **906609**

### [Problem 5 - Smallest multiple](https://projecteuler.net/problem=5)

**2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?**

When I think of the smallest number that each of the numbers from 1 to 10 can divide, I immediately think of prime numbers and exponents e.g. if a number is divisible by 4, it is divisible by 2 but a number divisible by 2 isn't necessarily divisible by 4. 

Every number can be expressed as a product of prime factors. The answer for 1 to 10 would be the product of each of the primes raised to the highest power that are less than 10. The primes below 10 are (2,3,5,7) with $2^3=8$, $3^2=9$, $5^1=5$ and $7^1=7$. Note that $8*9*5*7=2520$


```python
# We will use the is_prime function we created earlier.
ans=1
from math import log
for i in range(2,21):
    if is_prime(i):
        ans*=i**(int(log(20)/log(i)))
        # I'm calculating the floor of log(20) to base i.
        # This is the same as the highest power of i not greater than 20.
        
print(ans)
```

    232792560


Hence our solution is **232792560**

### [Problem 6 - Sum square difference](https://projecteuler.net/problem=6)

**The sum of the squares of the first ten natural numbers is, $1^2 + 2^2 + ... + 10^2 = 385$. 
The square of the sum of the first ten natural numbers is, $(1 + 2 + ... + 10)^2 = 55^2 = 3025$.
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025 − 385 = 2640$.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.**

This seems relatvely straightforward. We can do this via list comprehenshions in Python. We create the squared list using a list comprehenshion.


```python
# List of numbers from 1:100
nat=list(range(101))

# Use a list comprehenshion to create a list of squares.
nat2=[x**2 for x in nat]

# We do a quick check to see we have it right
print(nat[0:6])
print(nat2[0:6])

# Calculating the difference between the sum of the squares - square of the sum
ans=(sum(nat)**2)-sum(nat2)
print(ans)
```

    [0, 1, 2, 3, 4, 5]
    [0, 1, 4, 9, 16, 25]
    25164150


The answer is thus **25,164,150**


### [Problem 7 - 10001st prime](https://projecteuler.net/problem=7)

**By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10,001st prime number?**

Lets think about this. There's an obvious prime search approach so I will go in with that. There are few things we can do to avoid searching through many numbers. With the exception of 2, all primes are odd so we can start with 3 and move up in steps of 2


```python
# Let's create a function that outputs the nth prime. We will use our is_prime function again.
def nth_prime(n):
    if n==1:
        return(2)
    if n==2:
        return(3)
    count=2 # The order of the prime
    k=3 # The latest number
    while count<n:
        if is_prime(k+2):
            count+=1
        k+=2
    return(k)

### Now let's test it.
nth_prime(6) # Should give us 13.
```




    13




```python
# Excellent so let's do it for our problem.
nth_prime(10001)

# The answer is 104743
```




    104743



Hence our solution is **104743**

### [Problem 8 - Largest product in a series](https://projecteuler.net/problem=8)

**The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832**

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

**Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?**

Ok, this looks like another straightfoward one. I'll create a function that searches through the large number, calculates the products and returns the group with the largest product


```python
# First we load in the number. That in itself required some effort :)

y=7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

from numpy import product
def big_prod(y,k):    
    # y is the large number, k is the number of adjacent digits
    ans=0 # initialise the answer at zero
    
    # Convert the number to string and treat it that way
    y_str=str(y)
    n=len(y_str)
    nums=list('0'*k)
    
    for i in range(n-k+1):
        # Select a window of k digits with convert it to a list of string
        m=list(y_str[i:i+k])
        # Use a list comprehenshion to convert the list of string to a list of integers
        m1=[int(x) for x in m]
        # Find the product of that string and compare
        m2=product(m1)
        if m2>ans:
            nums=m
            ans=m2
    print(ans) # Print the largest product
    return(nums)



```


```python
big_prod(y,4)
big_prod(y,13)

```

    5832
    23514624000





    ['5', '5', '7', '6', '6', '8', '9', '6', '6', '4', '8', '9', '5']



Hence our solution is **23514624000**

### [Problem 9 - Special Pythagorean triplet](https://projecteuler.net/problem=9)

**A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, **

$a^2 + b^2 = c^2$
**For example,** $3^2 + 4^2 = 9 + 16 = 25 = 5^2$.

**There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.**

I imagine we can approach this algebraically. That's my first instinct. However this is a coding exercise so I'll get the solutions by brute force and then calculate their product. There is perhaps a smoother or snappier solution available however, this is how I thought to do it. 
 
We know that $a < b < c$ , $a + b + c = 1000$ and since they form the sum of any two sides has to be greater than the third [Triangle Inequality](http://mathworld.wolfram.com/TriangleInequality.html).
Since $b - a >= 1$, $c - b >= 1$  therefore $c - a >= 2$ 

Given the triangle inequality, we know that c can be no higher than 499
Because of the conditions above, the most equitable division of sides is $a=332$, $b=333$, $c=335$ 
And c can be no lower than 335 and a can be no higher 332.

Hence we can run a double loop with a from 1 to 332, c from 335 to 500 and subtract them from 1000 to find b. I will not include a break condition just in case there exists another pythagorean triplet that satisfies the conditions. I mean I know it says there's just one solution in the question - but you can't believe everything you're told can you?


```python
for a in range(1,333):
    for c in range(335,500):
        b=1000-a-c
        if a**2+b**2==c**2:
            print("a = "+ str(a) + ", b = "+str(b)+ " and c = " +str(c) + "." )
            ans = a*b*c
            
print("abc = " + str(ans))
```

    a = 200, b = 375 and c = 425.
    abc = 31875000


Hence our solution is **31875000**. I got a bit stuck on my theoretical solution for this problem and while it's interesting, I have had to move on from it in the interest of time. I looked online and found a solution on a site called [mathblog](https://www.mathblog.dk/pythagorean-triplets/). So have a look at that if you want to see a theoretical solution.

### [Problem 10 - Summation of primes](https://projecteuler.net/problem=10)

**The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.**

**Find the sum of all the primes below two million.**

Yet another prime number question. It's great because we can use the `is_prime` function we created earlier. I think I'll make a modification of one the functions I created for an earlier problem.


```python
def prime_less(n):
    count=0
    primes=''
    for i in range(2,n):
        if is_prime(i):
            count+=i
            
            # I created code to print the primes used
            # However, there are too many primes less than 2 million (duh)
            # So printing is perhaps not the answer. I'll only print if n < 1000
            # but leave it here in case you  
            if i == 2:
                primes='The sum is: 2'
            else:
                primes+=' + ' + str(i)
            #Let's print the primes being summed.
    if n<1000:
        print(primes)
    return(count)

print(prime_less(10)) # Let's test it.
# It has worked for 10. So let's test it for two million

prime_less(2000000) # 2 million is a big number so the code takes a while to run. The solution is 142913828922
```

    The sum is: 2 + 3 + 5 + 7
    17





    142913828922



Hence our solution is **142913828922**

### [Problem 11 - Largest product in a grid](https://projecteuler.net/problem=11)

** In the 20×20 grid below, four numbers along a diagonal line have been marked in red. **

08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08

49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00

81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65

52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91

22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80

24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50

32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70

67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21

24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72

21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95

78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92

16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57

86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58

19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40

04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66

88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69

04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36

20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16

20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54

01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48

**The product of these numbers is 26 × 63 × 78 × 14 = 1788696.**

**What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?**

There doesn't seem to be an analytical way of approaching this one. So we'll approach it by brute force. We'll load in the numbers as a numpy matrix and calculate


```python
from numpy import matrix,prod

z1=matrix([[8,2,22,97,38,15,0,40,0,75,4,5,7,78,52,12,50,77,91,8],
[49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,4,56,62,0],
[81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,3,49,13,36,65],
[52,70,95,23,4,60,11,42,69,24,68,56,1,32,56,71,37,2,36,91],
[22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80],
[24,47,32,60,99,3,45,2,44,75,33,53,78,36,84,20,35,17,12,50],
[32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70],
[67,26,20,68,2,62,12,20,95,63,94,39,63,8,40,91,66,49,94,21],
[24,55,58,5,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72],
[21,36,23,9,75,0,76,44,20,45,35,14,0,61,33,97,34,31,33,95],
[78,17,53,28,22,75,31,67,15,94,3,80,4,62,16,14,9,53,56,92],
[16,39,5,42,96,35,31,47,55,58,88,24,0,17,54,24,36,29,85,57],
[86,56,0,48,35,71,89,7,5,44,44,37,44,60,21,58,51,54,17,58],
[19,80,81,68,5,94,47,69,28,73,92,13,86,52,17,77,4,89,55,40],
[4,52,8,83,97,35,99,16,7,97,57,32,16,26,26,79,33,27,98,66],
[88,36,68,87,57,62,20,72,3,46,33,67,46,55,12,32,63,93,53,69],
[4,42,16,73,38,25,39,11,24,94,72,18,8,46,29,32,40,62,76,36],
[20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,4,36,16],
[20,73,35,29,78,31,90,1,74,31,49,71,48,86,81,16,23,57,5,54],
[1,70,54,71,83,51,54,69,16,92,33,48,61,43,52,1,89,19,67,48]])
```


```python
max_prod=0
indices=''
# we perform a horizontal, vertical and diagonal check
for i in range(20):
    for j in range(20):
        # Vertical check
        if i < 16:
            if z1[i:(i+4),j].prod()>max_prod:
                max_prod=z1[i:(i+4),j].prod()
                indices=str((i,j)) + ' , ' + str((i+1,j)) + ' , ' + str((i+2,j)) + ' , '+str((i+3,j))
       # Horizontal check
        if j < 16:
            if z1[i,j:(j+4)].prod()>max_prod:
                max_prod=z1[i,j:(j+4)].prod()
                indices=str((i,j)) + ' , ' + str((i,j+1)) + ' , ' + str((i,j+2)) + ' , '+str((i,j+3))

         # Diagonal check
        if (j < 16) and (i < 16):
            # Downward diagonal
            if z1[i:(i+4),j:(j+4)].diagonal().prod()>max_prod:
                max_prod=z1[i:(i+4),j:(j+4)].diagonal().prod() # Product of the diagonal of the array
                indices=str((i,j)) + ' , ' + str((i+1,j+1)) + ' , ' + str((i+2,j+2)) + ' , '+str((i+3,j+3))
        
            # To find the other diagonal, we reverse the 
            # Upward diagonal
            if z1[i:(i+4),j:(j+4)][::-1].diagonal().prod()>max_prod:
                max_prod=z1[i:(i+4),j:(j+4)][::-1].diagonal().prod() # Product of the opposite diagonal of the array
                indices=str((i,j+3)) + ' , ' + str((i+1,j+2)) + ' , ' + str((i+2,j+1)) + ' , '+str((i+3,j))

print(indices)
print(max_prod)              
                
```

    (12, 6) , (13, 5) , (14, 4) , (15, 3)
    70600674


The solution is therefore **70600674** and while not asked to, I also printed out the solution cells: **(13, 7) , (14, 6) , (15, 5) and (16, 4)** (recall python indexing starts at zero).

08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08

49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00

81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65

52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91

22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80

24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50

32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70

67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21

24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72

21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95

78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92

16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57

86 56 00 48 35 71 **<font color='red'> 89 </font>** 07 05 44 44 37 44 60 21 58 51 54 17 58

19 80 81 68 05 **<font color='red'> 94 </font>** 47 69 28 73 92 13 86 52 17 77 04 89 55 40

04 52 08 83 **<font color='red'> 97 </font>** 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66

88 36 68 **<font color='red'> 87 </font>** 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69

04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36

20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16

20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54

01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48

### [Problem 12 - Highly divisible triangular number](https://projecteuler.net/problem=12)

**The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:**

**1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...**

**Let us list the factors of the first seven triangle numbers:**

 1: 1
 
 3: 1,3
 
 6: 1,2,3,6

10: 1,2,5,10

15: 1,3,5,15

21: 1,3,7,21

28: 1,2,4,7,14,28

**We can see that 28 is the first triangle number to have over five divisors.**

**What is the value of the first triangle number to have over five hundred divisors?**

Ok, let's brute-ish force this one first and then see if we can think of a more interesting solution. This will be the last one I do in this part (12 seems like a sensible number to pause at).

Mathematically speaking, this is an [arithmetic progression](https://en.wikipedia.org/wiki/Arithmetic_progression). As shown in the derivation, we can represent the nth triangular number as:
$$Tri(n)=\frac{n(n+1)}{2} $$

Now looking at the set up above, one of $n$ and $n+1$ will be even. So we find the divisors of $n/2$ and $n+1$ (or (n+1)/2 and n if n is odd). We then cross multiply both and the unique list will be all of the divisors. 



```python
# First create a function to generate the nth triangle number
def tri(n):
    return(0.5*n*(n+1))

# Let's test this out.
print(tri(1),tri(2),tri(3)) # Looks like it works

# Now let's create a function that creates a tuple of the divisors
def divs(k):
    # We know that automatically, we have 1 and the number k
    nums=[1,]
    
    for j in range(2,int(k*0.5)+1):
        if k%j==0:
            nums=nums+[j,]
    
    nums=nums+[k,]
    return(nums)

# Test for 15. 
divs(15) # Looks like it works


```

    1.0 3.0 6.0





    [1, 3, 5, 15]




```python
# We know the 7th triangular number is 28 so we'll start from the 8th
# n/2 is even, k_even=n/2 else, k_odd=n/2

n=7
m=len(divs(tri(7)))
while m<501:
    n+=1
    if n%2==0:
        k_even,k_odd=n/2,(n+1)
    else:
        k_even,k_odd=(n+1)/2,n
        
    t1,t2=divs(k_even),divs(k_odd)
    t3=set([x*y for x in t1 for y in t2]) # Multiply all the elements together using a list comprehenshion
    # Get a unique list of them using set.
    m=len(t3)
    
print("There are "+ str(m) + " divisors for " + str(int(tri(n)))+ " the " + str(n)+"th triangular number.")
```

    There are 576 divisors for 76576500 the 12375th triangular number.


Hence our solution is **76576500**.

That's it from me for the first 12 problems. Thanks a lot for reading. Please let me know if you spot any errors or have any suggestions. I'm also grateful for any feedback.

Thanks!
